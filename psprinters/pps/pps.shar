#! /bin/sh
# This is a shell archive. Remove anything before this line, then feed it
# into a shell via "sh file" or similar. To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sou...@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
# "End of shell archive."
# Contents: pps.1 Makefile p2ps.sh pps.sh preps.c
# Wrapped by pe...@neosoft.com on Fri Dec 18 15:32:52 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'pps.1' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'pps.1'\"
else
echo shar: Extracting \"'pps.1'\" \(5157 characters\)
sed "s/^X//" >'pps.1' <<'END_OF_FILE'
X.TH PPS 1 "12 DEC 1992"
X.SH NAME
Xpps, preps \- Easily mungable PostScript pretty-printer
X.SH SYNOPSIS
X.B preps
X[
X.BI -t tabwidth
X] [
X.BI -w pagewidth
X] [
X.B -f
X] [
X.BI -m magic
X] [
X.IR file ...
X]
X.br
X.B pps
X[
X.B -ISO
X] [
X.B -t
X.I tabwidth
X] [
X.B -l
X.I lines
X] [
X.B -c
X.I cols
X] [
X.B -h
X.I title
X] [
X.B -f
X.I font
X] [
X.B -F
X.I font
X] [
X.B -d
X.I date
X] [
X.BR -L [ L ]]
X[
X.BR -N [\fIperiod\fR]]
X[
X.IR file ...
X]
X.SH DESCRIPTION
XThese programs are a highly versatile set of tools for generating nice
Xlistings on a PostScript printer. Since most of the formatting is done in
XPostScript, it's easy to extend and modify. There is a variant script
Xshipped with
X.B pps
Xfor printing 2-up in an unusual fashion. It's based on an older version of
X.B pps
Xso it doesn't have as many bells and whistles. Creating your own script is
Xpretty easy.
X.PP
X.B PPS
Xis a shell script that outputs text in PostScript. It puts a header on
Xeach page, indicates the end of the file in an unambiguous fashion, and
Xgenerally makes life easier.
X.PP
X.B PREPS
Xis a preprocessor for PostScript. It converts a text file with tabs and
Xoverstrikes into something more easily mungable. For example:
X.PP
X.nf
X/FILEDATE (Sat Dec 12 19:53:16 CST 1992) def
X/DATEFONT ITALIC def
X/FILENAME (example)def
X/NAMEFONT ITALIC def
XBOF
XNL BOLD (PREPS ) P NORMAL (is a preprocessor for PostScript.) P
XEOF
X.fi
X.PP
XWith an appropriate header (such as the one generated by
X.BR pps )
Xyou can easily make the output look like anything you want.
XFor example, to truncate rather than wrapping lines, change the code for
X.B WRAP
Xto set a "no output" flag that
X.B NL
Xand
X.B P
Xand so on honor.
X.SH OPTIONS
X.SS PREPS
X.IP -t
Xspecifies the width of a tab, in characters.
X.IP -w
Xspecifies the width of the page, in characters.
X.IP -f
Xindicates that
X.B preps
Xis being used as a filter, so don't generate
X.B BOF
Xand
X.B EOF
Xcommands.
X.IP -m
Xspecifies the ``magic''
Xstring to use. If this string is seen at the beginning of a line, the rest
Xof the line is passed straight through to Postscript. So, a special-purpose
Xpretty-printer could put font changes and the like here.
X.IP
XIt's guaranteed that the current text style will be
X.B NORMAL
Xwhen this code is executed, and that there will be a text style selection
Xcommand before any further output, in case you need to redefine these
Xwords.
X.SS PPS
X.IP -ISO
XReencode the fonts used to display ISO 8859.1 characters.
X.IP -t
Xspecifies the width of a tab, in characters.
X(default 8)
X.IP -l
Xthe number of lines to display on each page.
X(default 66)
X.IP -c
Xthe number of columns to display on each page.
X(default 80)
X.IP -h
Xspecifies the default title if no files are specified.
X(Standard Input)
X.IP -f
Xspecifies the font to use for the "trimming".
X(Times-Bold)
X.br
XIt is assumed that the alternate form is "Italic". If you want to use a
Xsan-serif font like Helvetica, you will have to make
X.B pps
Xsmarter.
X.IP -F
Xspecifies the font to use for line numbers.
X(Times-Roman)
X.IP -d
XThe default date if no files are specified.
X(now)
X.IP -L
Xshorthand for \fB-l 99 -c 120\fR.
X.IP -LL
Xshorthand for \fB-l 132 -c 160\fR
X.IP -N\fIperiod\fR
XPrint line numbers in the margin every
X.I period
Xlines. Note that wrapped lines aren't included twice in the count.
X(default period is 10 lines)
X.SH PROGRAMMING
X.B Preps
Xgenerates the following codes:
X.IP "\fIstring \fBP\fR"
XPrint the string at the current location on the page.
X.IP "\fIcolumn \fBT\fR"
XIndent to the column indicated (in character positions).
X.IP "\fBNL\fR"
XBegin a new line, also generated after a
X.BR WRAP .
X.IP "\fBWRAP\fR"
XThe next line will be a continuation of the current line.
X.IP "\fBBOLD\fR"
XThe following text should be displayed in boldface.
X.IP "\fBSLANT\fR"
XThe following text should be displayed underlined or in italics.
X.IP "\fBNORMAL\fR"
XThe following text has no special attributes.
X.IP "\fIarray \fBOS\fR"
XOverstrike. The array contains a sequence of characters to be displayed
Xoverstruck in a single character position.
X.IP "\fBEOF\fR"
XEnd of current file.
X.IP "\fBFF\fR"
XEnd of page (form feed).
X.IP "\fBBOF\fR"
XBeginning of new file. The following Postscript variables will be set at
Xthis point:
X.RS
X.IP "\fBFILENAME\fI (string)\fR"
XName of the file currently being printed. If not known, the value
X.B TITLE
Xwill be used, and should be defined in the Postscript prologue.
X.IP "\fBNAMEFONT\fI (scaled font)\fR"
XFont, one of
X.B ROMAN
Xor
X.BR ITALIC .
XThese should be defined by the PostScript prologue.
X.IP "\fBFILEDATE\fI (string)\fR"
XDate the file being printed was last modified. If standard input
Xis being fed to
X.B preps
Xthen
X.B DATE
Xwill be used. This should be set in the PostScript prologue.
X.IP "\fBDATEFONT\fI (scaled font)\fR"
XFont, as above.
X.RE
X.SH AUTHOR
XPeter da Silva.
X.SH NOTES
XI wrote this because I was sick of the cute postscript pretty-printers
Xwritten entirely in C or PostScript that produced output I couldn't stand
Xto look at and were too much trouble to hack. At least if you can't
Xstand the output, you can fix it.
X.SH BUGS
XArgument parsing in
X.B pps
Xis primitive. All options that take an argument MUST be followed by a
Xspace, except that
X.B -N
Xmust NOT be followed by a space. Sad, eh?
END_OF_FILE
if test 5157 -ne `wc -c <'pps.1'`; then
echo shar: \"'pps.1'\" unpacked with wrong size!
fi
# end of 'pps.1'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(527 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XBINDIR=/net/jaguar/home/bin
XMANDIR=/net/jaguar/home/man
XSHELL=/bin/sh
X
Xall: preps
X
Xinstall: $(BINDIR)/p2ps $(BINDIR)/pps $(BINDIR)/preps $(MANDIR)/man1/pps.1
X
Xpps.shar: pps.1 Makefile p2ps.sh pps.sh preps.c
X shar pps.1 Makefile p2ps.sh pps.sh preps.c > pps.shar
X
X$(BINDIR)/p2ps: p2ps.sh
X cp p2ps.sh $(BINDIR)/p2ps
X
X$(BINDIR)/pps: pps.sh
X cp pps.sh $(BINDIR)/pps
X
X$(BINDIR)/preps: preps
X cp preps $(BINDIR)
X
X$(MANDIR)/man1/pps.1: pps.1
X cp pps.1 $(MANDIR)/man1/pps.1
X
Xpsprint:
X pps -N Makefile p2ps.sh pps.sh preps.c | lpr -Pps
END_OF_FILE
if test 527 -ne `wc -c <'Makefile'`; then
echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'p2ps.sh' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'p2ps.sh'\"
else
echo shar: Extracting \"'p2ps.sh'\" \(3388 characters\)
sed "s/^X//" >'p2ps.sh' <<'END_OF_FILE'
Xlines=60
Xcols=80
Xtabs=8
Xtitle="Standard Input"
Xdate="`date`"
Xwhile
X case $1 in
X -h)
X shift
X title="$1"
X shift
X true;;
X -d)
X shift
X date="$1"
X shift
X true;;
X -l)
X shift
X lines=$1
X shift
X true;;
X -c)
X shift
X cols=$1
X shift
X true;;
X -t)
X shift
X tabs=$1
X shift
X true;;
X -*)
X echo "Usage: %s [-t tabs] [-l lines] [-c cols] [-h title] [-d date] [file]..." 1>&2
X exit 2;;
X *)
X false;;
X esac
Xdo :
Xdone
X
Xecho "%!"
Xecho "/LINES $lines def"
Xecho "/COLS $cols def"
Xecho "/DATE ($date) def"
Xecho "/TITLE ($title) def"
X
Xcat << \!
X/inch { 72 mul } def
X
X% Tune the page appearance here:
X%GS% Denotes the "nice" settings for Ghostscript
X%LN% For DEC LN03-R
X
X% Fonts and line spacing...
X/YSCALE 7.5 inch LINES 1 add div def
X/XSCALE 4.5 inch 0.6 div COLS div def
X/SCALE [XSCALE 0 0 YSCALE 0 0] def
X/courier-normal /Courier findfont SCALE makefont def
X/courier-slant /Courier-Oblique findfont SCALE makefont def
X/courier-bold /Courier-Bold findfont SCALE makefont def
X/courier courier-normal def
X/ROMAN /NewCenturySchlbk-Bold findfont 12 scalefont def
X/ITALIC /NewCenturySchlbk-BoldItalic findfont 12 scalefont def
X/spacing YSCALE def
X
X/indent 0.5 inch def
X
X% Where does the title bar go?
X/bar 10.25 inch def
X
X/mbar 5.25 inch def
X
X% Where does the text go?
X/margin1 bar 0.125 inch sub def
X/margin2 mbar 0.125 inch sub def
X/top 7.5 inch spacing sub def
X/bottom 0 def
X/chwidth 4.5 inch COLS div def
X/colno 0 def
X
X% Where does the title go?
X/titleplace bar 6 add def
X/left 0.5 inch def
X/right 8 inch def
X/middle 4.25 inch def
X
X% Generally don't want to mess with this:
X
X/NORMAL { /courier courier-normal def } def
X/BOLD { /courier courier-bold def } def
X/SLANT { /courier courier-slant def } def
X
X/BOF {
X /line -1 def
X /pno 0 def
X} def
X
X/title {
X newpath 0.5 inch bar moveto 8 inch bar lineto stroke
X NAMEFONT setfont
X 0.5 inch titleplace moveto
X FILENAME show
X DATEFONT setfont
X right FILEDATE stringwidth pop sub titleplace moveto
X FILEDATE show
X ROMAN setfont
X pno 1 add dup /pno exch def ( ) cvs
X dup
X stringwidth pop 2 div middle exch sub titleplace moveto
X show
X /line top def
X /colno 0 def
X} def
X
X/newpage {
X colno 0 eq {
X /colno 1 def
X /line top def
X pno 1 add dup /pno exch def ( ) cvs
X dup
X stringwidth pop 2 div middle exch sub mbar 6 add moveto
X show
X newpath 0.5 inch mbar moveto 8 inch mbar lineto stroke
X } {
X showpage
X title
X } ifelse
X} def
X
X/NL {
X line spacing sub bottom lt {
X line -1 eq {
X title
X } {
X newpage
X } ifelse
X } {
X /line line spacing sub def
X } ifelse
X /col 0 def
X} def
X/FF {
X newpage
X} def
X/EOF {
X line -1 ne { showpage } if
X BOF
X} def
X/trans {
X indent colno 0 eq { margin1 } { margin2 } ifelse translate
X 270 rotate
X} def
X/P {
X gsave trans
X courier setfont
X col line moveto
X dup show
X stringwidth pop col add /col exch def
X grestore
X} def
X/WRAP {
X gsave trans
X newpath
X 4.625 inch line moveto
X 4.625 inch line spacing 2 div add lineto
X 4.625 inch spacing 4 div add line spacing 4 div add lineto
X closepath fill
X grestore
X} def
X/T {
X chwidth mul /col exch def
X} def
X/OS {
X gsave trans
X courier setfont
X dup {
X col line moveto show
X } forall
X 0 exch {
X stringwidth pop 2 copy lt {
X exch
X } if pop
X } forall col add /col exch def
X grestore
X} def
X!
Xpreps -l$lines -t$tabs ${1+"$@"}
END_OF_FILE
if test 3388 -ne `wc -c <'p2ps.sh'`; then
echo shar: \"'p2ps.sh'\" unpacked with wrong size!
fi
chmod +x 'p2ps.sh'
# end of 'p2ps.sh'
fi
if test -f 'pps.sh' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'pps.sh'\"
else
echo shar: Extracting \"'pps.sh'\" \(8343 characters\)
sed "s/^X//" >'pps.sh' <<'END_OF_FILE'
Xlines=66
Xcols=80
Xtabs=8
Xtitle="Standard Input"
Xtitlefont="Times-Bold"
Xnumberfont="Times-Roman"
Xtitlesize=12
Xdate="`date`"
Xnumber=false
Xiso=false
Xperiod=10
Xwhile
X case $1 in
X -ISO)
X shift
X iso=true
X true;;
X -h)
X shift
X title="$1"
X shift
X true;;
X -d)
X shift
X date="$1"
X shift
X true;;
X -l)
X shift
X lines=$1
X shift
X true;;
X -c)
X shift
X cols=$1
X shift
X true;;
X -t)
X shift
X tabs=$1
X shift
X true;;
X -f)
X shift
X titlefont=$1
X shift
X true;;
X -F)
X shift
X numberfont=$1
X shift
X true;;
X -L)
X shift
X lines=99
X cols=120
X true;;
X -LL)
X shift
X lines=132
X cols=160
X true;;
X -N)
X shift
X number=true
X true;;
X -N*)
X period=`echo $1 | sed 's/-N//'`
X shift
X number=true
X true;;
X -*)
X echo "Usage: pps [-t tabs] [-l lines] [-c cols] [-h title]" 1>&2
X echo " [-[fF] font] [-d date] [-L[L]] [-N[period]]" 1>&2
X echo " [file]..." 1>&2
X exit 2;;
X *)
X false;;
X esac
Xdo :
Xdone
X
Xecho "%!"
X
Xif [ "$iso" = "true" ]
Xthen
Xcat << \!
X%Define ISO Character Set
X
X/reencsmalldict 12 dict def
X/ReEncodeSmall
X{ reencsmalldict begin
X /newcodesandnames exch def
X /newfontname exch def
X /basefontname exch def
X
X /basefontdict basefontname findfont def
X /newfont basefontdict maxlength dict def
X
X basefontdict
X { exch dup /FID ne
X { dup /Encoding eq
X { exch dup length array copy newfont 3 1 roll put }
X { exch newfont 3 1 roll put }
X ifelse
X }
X { pop pop }
X ifelse
X } forall
X
X newfont /FontName newfontname put
X newcodesandnames aload pop
X
X newcodesandnames length 2 idiv
X { newfont /Encoding get 3 1 roll put } repeat
X
X newfontname newfont definefont pop
X end
X} def
X
X/ISOVec[
X16#27 /quotesingle 16#60 /grave 16#7C /bar
X16#91 /quoteleft 16#92 /quoteright 16#93 /quotedblleft
X16#94 /quotedblright 16#95 /bullet 16#96 /endash
X16#97 /emdash 16#99 /trademark 16#9A /scaron
X16#9B /guilsinglright 16#9C /oe 16#9F /Ydieresis
X16#A0 /space 16#A4 /currency 16#A6 /brokenbar
X16#A7 /section 16#A8 /dieresis 16#A9 /copyright
X16#AA /ordfeminine 16#AB /guillemotleft 16#AC /logicalnot
X16#AD /hyphen 16#AE /registered 16#AF /macron
X16#B0 /degree 16#B1 /plusminus 16#B2 /twosuperior
X16#B3 /threesuperior 16#B4 /acute 16#B5 /mu
X16#B6 /paragraph 16#B7 /periodcentered 16#B8 /cedilla
X16#B9 /onesuperior 16#BA /ordmasculine 16#BB /guillemotright
X16#BC /onequarter 16#BD /onehalf 16#BE /threequarters
X16#BF /questiondown 16#C0 /Agrave 16#C1 /Aacute
X16#C2 /Acircumflex 16#C3 /Atilde 16#C4 /Adieresis
X16#C5 /Aring 16#C6 /AE 16#C7 /Ccedilla
X16#C8 /Egrave 16#C9 /Eacute 16#CA /Ecircumflex
X16#CB /Edieresis 16#CC /Igrave 16#CD /Iacute
X16#CE /Icircumflex 16#CF /Idieresis 16#D0 /Eth
X16#D1 /Ntilde 16#D2 /Ograve 16#D3 /Oacute
X16#D4 /Ocircumflex 16#D5 /Otilde 16#D6 /Odieresis
X16#D7 /multiply 16#D8 /Oslash 16#D9 /Ugrave
X16#DA /Uacute 16#DB /Ucircumflex 16#DC /Udieresis
X16#DD /Yacute 16#DE /Thorn 16#DF /germandbls
X16#E0 /agrave 16#E1 /aacute 16#E2 /acircumflex
X16#E3 /atilde 16#E4 /adieresis 16#E5 /aring
X16#E6 /ae 16#E7 /ccedilla 16#E8 /egrave
X16#E9 /eacute 16#EA /ecircumflex 16#EB /edieresis
X16#EC /igrave 16#ED /iacute 16#EE /icircumflex
X16#EF /idieresis 16#F0 /eth 16#F1 /ntilde
X16#F2 /ograve 16#F3 /oacute 16#F4 /ocircumflex
X16#F5 /otilde 16#F6 /odieresis 16#F7 /divide
X16#F8 /oslash 16#F9 /ugrave 16#FA /uacute
X16#FB /ucircumflex 16#FC /udieresis 16#FD /yacute
X16#FE /thorn 16#FF /ydieresis
X] def
X
X/Courier /ISO-Courier ISOVec ReEncodeSmall
X/Courier-Bold /ISO-Courier-Bold ISOVec ReEncodeSmall
X/Courier-Oblique /ISO-Courier-Oblique ISOVec ReEncodeSmall
X!
X echo "/$titlefont /ISO-$titlefont ISOVec ReEncodeSmall"
X echo "/${titlefont}Italic /ISO-${titlefont}Italic ISOVec ReEncodeSmall"
X if [ "$number" = "true" ]
X then echo "/$numberfont /ISO-$numberfont ISOVec ReEncodeSmall"
X fi
X titlefont=ISO-$titlefont
X numberfont=ISO-$numberfont
X courier=ISO-Courier
Xelse
X courier=Courier
Xfi
X
Xecho "/LINES $lines def"
Xecho "/COLS $cols def"
Xecho "/DATE ($date) def"
Xecho "/TITLE ($title) def"
Xecho "/ROMANFONT /${titlefont} def"
Xecho "/ITALICFONT /${titlefont}Italic def"
Xecho "/FONTSIZE $titlesize def"
Xif [ "$number" = "true" ]
Xthen echo "/NUMBERFONT /$numberfont def"
Xfi
Xecho "/NORMALFONT /$courier def"
Xecho "/SLANTFONT /$courier-Oblique def"
Xecho "/BOLDFONT /$courier-Bold def"
X
Xif [ "$number" = "false" ]
Xthen echo "/numberline {} def /reset_numbers {} def"
Xelse
Xecho "/period $period def"
Xcat << \!
X
X/NUMBER NUMBERFONT findfont FONTSIZE scalefont def
X
X/reset_numbers {
X /line_number 0 def
X} def
X
X/numberline {
X /line_number line_number 1 add def
X line_number period mod 0 eq {
X gsave
X indent spacing 2 mul sub line translate
X spacing 2 mul 3 div FONTSIZE div
X dup scale
X NUMBER setfont
X line_number ( ) cvs
X dup stringwidth pop neg 0 moveto
X show
X grestore
X } if
X} def
X!
Xfi
X
Xcat << \!
X/inch { 72 mul } def
X
X% Tune the page appearance here:
X%GS% Denotes the "nice" settings for Ghostscript
X%LN% For DEC LN03-R
X
X/xsize 6.5 inch def
X%LN%/ysize 9.5 inch def
X%GS%/ysize 10 inch def
X/ysize 9.5 inch def
X
X% Fonts and line spacing...
X/xscale xsize 0.6 div COLS div def
X/yscale ysize LINES div def
X/fontscale [xscale 0 0 yscale 0 0] def
X/fixed-normal NORMALFONT findfont fontscale makefont def
X/fixed-slant SLANTFONT findfont fontscale makefont def
X/fixed-bold BOLDFONT findfont fontscale makefont def
X/FIXED fixed-normal def
X/ROMAN ROMANFONT findfont FONTSIZE scalefont def % ROMAN called from preps
X/ITALIC ITALICFONT findfont FONTSIZE scalefont def % ITALIC called from preps
X
X% Where does the text go?
X/bottom 0.5 inch def
X/top bottom ysize add def
X/indent 1.0 inch def
X/margin indent xsize add def
X/chwidth margin indent sub COLS div def
X/spacing yscale def
X
X% Where does the title bar go?
X/bar top 0.25 inch add def
X
X% Where does the title go?
X/titleplace bar 10 add def
X/left 0.5 inch def
X/right 8 inch def
X/middle 4.25 inch def
X
X% Size of the little arrow at the bottom of the page
X/ptroff 0.0625 inch def
X/ptrwidth 0.0625 inch def
X/ptrheight ptrwidth 2 mul def
X
X% Generally don't want to mess with this:
X
X/NORMAL { /FIXED fixed-normal def } def
X/BOLD { /FIXED fixed-bold def } def
X/SLANT { /FIXED fixed-slant def } def
X
X/BOF {
X /line -1 def
X /pno 0 def
X /wrapped false def
X reset_numbers
X} def
X
X/tag {
X gsave
X right ptroff add ptrwidth add
X exch translate
X 90 rotate
X 0.5 0.5 scale
X 0 0 moveto
X NAMEFONT setfont
X FILENAME show
X grestore
X} def
X
X/title {
X newpath left bar moveto right bar lineto stroke
X DATEFONT setfont
X left titleplace moveto
X FILEDATE show
X NAMEFONT setfont
X right FILENAME stringwidth pop sub titleplace moveto
X FILENAME show
X ROMAN setfont
X pno 1 add dup /pno exch def ( ) cvs
X dup stringwidth pop 2 div middle exch sub titleplace moveto show
X /line top def
X} def
X/EOP {
X newpath
X right ptroff add % column
X dup bottom moveto
X dup ptrwidth 2 div add bottom ptrheight sub lineto
X ptrwidth add bottom lineto
X closepath fill
X bottom ptroff add tag
X showpage
X} def
X/NL {
X line spacing sub bottom lt {
X line -1 ne { EOP } if
X title
X } {
X /line line spacing sub def
X } ifelse
X /col indent def
X wrapped { unwrap } { numberline } ifelse
X} def
X/FF {
X EOP title
X} def
X/EOF {
X /line line spacing sub def
X line bottom ge {
X newpath left line moveto right line lineto stroke
X } if
X line tag
X showpage
X BOF
X} def
X/WRAP {
X newpath
X margin ptroff add
X dup line moveto
X dup line spacing 2 div add lineto
X spacing 4 div add line spacing 4 div add lineto
X closepath fill
X /wrapped true def
X} def
X/unwrap {
X newpath
X indent ptroff sub
X dup line moveto
X dup line spacing 2 div add lineto
X spacing 4 div sub line spacing 4 div add lineto
X closepath fill
X /wrapped false def
X} def
X/P {
X FIXED setfont
X col line moveto
X dup show
X stringwidth pop col add /col exch def
X} def
X/T {
X chwidth mul indent add /col exch def
X} def
X/OS {
X FIXED setfont
X dup {
X col line moveto show
X } forall
X 0 exch {
X stringwidth pop 2 copy lt {
X exch
X } if pop
X } forall col add /col exch def
X} def
X!
Xpreps -w$cols -t$tabs ${1+"$@"}
END_OF_FILE
if test 8343 -ne `wc -c <'pps.sh'`; then
echo shar: \"'pps.sh'\" unpacked with wrong size!
fi
chmod +x 'pps.sh'
# end of 'pps.sh'
fi
if test -f 'preps.c' -a "${1}" != "-c" ; then
echo shar: Will not clobber existing file \"'preps.c'\"
else
echo shar: Extracting \"'preps.c'\" \(6381 characters\)
sed "s/^X//" >'preps.c' <<'END_OF_FILE'
X/* Preprocessor for text to pretty-print it in Postscript. */
X#include <ctype.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#define MAXDEPTH 8
X#define MAXWIDTH 512
X#define MAXBUFFER (MAXDEPTH * MAXWIDTH)
X
Xint width = 80;
Xint tabstops = 8;
Xint filter = 0;
Xchar *magic = NULL;
Xint magiclen = 0;
X
Xchar *prog;
Xchar option;
X
Xchar *strrchr();
X
Xusage(s)
Xchar *s;
X{
X fprintf(stderr, "%s:", prog);
X if(option) fprintf(stderr, " -%c:", option);
X fprintf(stderr, " %s\n", s);
X fprintf(stderr, "Usage: %s [-t<tabwidth>] [-w<pagewidth>] [-m<magic>] [-f] [file]....\n", prog);
X}
X
Xmain(ac, av)
Xint ac;
Xchar **av;
X{
X FILE *fp;
X static char buffer[MAXBUFFER];
X char *t, *ctime();
X struct stat sb;
X int val;
X
X if(prog = strrchr(*av, '/'))
X prog++;
X else
X prog = *av;
X
X while(*++av) {
X option = 0;
X if(**av == '-') {
X while(*++*av) {
X switch(option = **av) {
X case 'f':
X filter = !filter;
X break;
X case 'm':
X ++*av;
X if(!**av) {
X usage("Missing argument.\n");
X exit(2);
X }
X magic = *av;
X magiclen = strlen(magic);
X *av += magiclen-1;
X break;
X case 'w':
X case 't':
X ++*av;
X if(!**av) {
X usage("Missing argument.\n");
X exit(2);
X }
X if(!isdigit(**av)) {
X usage("Option requires numeric argument.\n");
X exit(2);
X }
X val = 0;
X while(isdigit(**av)) {
X val = val * 10 + **av - '0';
X ++*av;
X }
X --*av;
X switch(option) {
X case 'w': width = val; break;
X case 't': tabstops = val; break;
X }
X break;
X default:
X usage("Unknown option");
X exit(2);
X }
X }
X } else if(!(fp = fopen(*av, "r"))) {
X perror(fp);
X exit(1);
X } else {
X if(fstat(fileno(fp), &sb) == 0) {
X t = ctime(&sb.st_mtime);
X t[strlen(t)-1] = 0;
X printf("/FILEDATE (%s) def\n", t);
X printf("/DATEFONT ROMAN def\n");
X } else {
X printf("/FILEDATE DATE def\n");
X printf("/DATEFONT ITALIC def\n");
X }
X printf("/FILENAME (%s) def\n", *av);
X printf("/NAMEFONT ROMAN def\n");
X if(!filter) printf("BOF\n");
X initfile();
X while(fgets(buffer, sizeof(buffer), fp)) {
X puttext(buffer);
X }
X if(!filter) printf("EOF\n");
X }
X }
X if(!fp) {
X printf("/FILEDATE DATE def\n");
X printf("/DATEFONT ITALIC def\n");
X printf("/FILENAME TITLE def\n", *av);
X printf("/NAMEFONT ITALIC def\n");
X if(!filter) printf("BOF\n");
X initfile();
X while(fgets(buffer, sizeof(buffer), stdin)) {
X puttext(buffer);
X }
X if(!filter) printf("EOF\n");
X }
X}
X
Xchar workbuf[MAXDEPTH][MAXWIDTH];
Xint depth[MAXWIDTH];
Xint style[MAXWIDTH];
X#define NORMAL 0
X#define BOLD 1
X#define ITALIC 2
X#define UNKNOWN 3
Xchar *stylename[4] = {
X "NORMAL ", "BOLD ", "SLANT ", "(Can't Happen!) print "
X};
Xint oldstyle;
Xint col;
X
Xinitfile()
X{
X oldstyle = UNKNOWN;
X}
X
Xinitbuf()
X{
X int i;
X
X for(col = 0; col < width; col++) {
X depth[col] = 0;
X style[col] = UNKNOWN;
X for(i = 0; i < MAXDEPTH; i++) {
X workbuf[i][col] = 0;
X }
X }
X
X col = 0;
X}
X
Xbegintext()
X{
X printf("(");
X}
X
Xendtext()
X{
X printf(") P ");
X}
X
Xprintab(col)
Xint col;
X{
X printf("%d T ", col);
X}
X
Xprintos(col)
Xint col;
X{
X int i;
X printf("[ ");
X for(i = 0; i < depth[col]; i++) {
X printf("(");
X printchar(col, i);
X printf(") ");
X }
X printf("] OS ");
X}
X
Xprintchar(col, d)
Xint col, d;
X{
X char c = workbuf[d][col];
X
X if( (c & 0x80) == 0 ) {
X if(strchr("()\\", c))
X putchar('\\');
X putchar(c);
X }
X else printf("\\%03o", c & 0xFF);
X}
X
Xpatch_style()
X{
X int col, i;
X
X for(col = 0; col < width; col++) {
X if(workbuf[0][col] == ' ' || depth[col] == 0) {
X if(col == 0) {
X if(oldstyle == UNKNOWN)
X style[col] = NORMAL;
X else
X style[col] = oldstyle;
X } else {
X if(style[col-1] == UNKNOWN)
X style[col] = NORMAL;
X else
X style[col] = style[col-1];
X }
X } else if(workbuf[0][col] == '_' && style[col] == ITALIC) {
X if(col == 0 || style[col-1] != ITALIC)
X style[col] = BOLD;
X } else if(depth[col] > 1) {
X for(i = 1; i < depth[col]; i++)
X if(workbuf[i][col] != workbuf[i-1][col])
X break;
X if(i == depth[col]) {
X depth[col] = 1;
X style[col] = BOLD;
X }
X }
X }
X}
X
Xendline()
X{
X int intab = 0;
X int intext = 0;
X int col;
X int newstyle;
X
X patch_style();
X printf("NL ");
X for(col = 0; col < width; col++) {
X if(style[col] == UNKNOWN)
X newstyle = NORMAL;
X else
X newstyle = style[col];
X switch(depth[col]) {
X case 0:
X if(intext) {
X endtext();
X intext = 0;
X }
X intab = 1;
X break;
X case 1:
X if(intab) {
X printab(col);
X intab = 0;
X }
X if(oldstyle != newstyle) {
X if(intext) endtext();
X printf(stylename[newstyle]);
X begintext();
X intext = 1;
X oldstyle = newstyle;
X }
X else if(!intext) {
X begintext();
X intext = 1;
X }
X printchar(col, 0);
X break;
X default:
X if(intab) {
X printab(col);
X intab = 0;
X }
X if(intext) {
X endtext();
X intext = 0;
X }
X if(oldstyle != newstyle) {
X printf(newstyle);
X oldstyle = newstyle;
X }
X printos(col);
X break;
X }
X }
X if(intext)
X endtext();
X}
X
Xpchar(c)
Xchar c;
X{
X int i;
X
X if(col>=width) {
X endline();
X printf("WRAP ");
X initbuf();
X }
X
X switch(c) {
X case '_':
X if(depth[col] == 0) {
X depth[col] = 1;
X workbuf[0][col] = '_';
X } else if(depth[col] == 1) {
X if(style[col] == NORMAL || style[col] == UNKNOWN)
X style[col] = ITALIC;
X }
X break;
X case ' ':
X if(depth[col] == 0) {
X depth[col] = 1;
X workbuf[0][col] = ' ';
X }
X break;
X default:
X switch(workbuf[0][col]) {
X case '_':
X style[col] = ITALIC;
X case ' ':
X workbuf[0][col] = c;
X break;
X default:
X if(depth[col] < MAXDEPTH)
X workbuf[depth[col]++][col] = c;
X if(style[col] == UNKNOWN)
X style[col] = NORMAL;
X break;
X }
X break;
X }
X
X col++;
X}
X
Xptab()
X{
X col += tabstops - col%tabstops;
X}
X
Xpcr()
X{
X col = 0;
X}
X
Xpbs()
X{
X if(col>0) col--;
X}
X
Xpff()
X{
X endline();
X printf("FF\n");
X}
X
Xputtext(s)
Xchar *s;
X{
X if(magic && (strncmp(s, magic, magiclen) == 0)) {
X s += magiclen;
X if(oldstyle != NORMAL)
X printf("%s", stylename[NORMAL]);
X oldstyle = UNKNOWN;
X printf("%s", s);
X return;
X }
X
X initbuf();
X
X while(*s) {
X switch(*s) {
X case '\b': pbs(); break;
X case '\t': ptab(); break;
X case '\r': pcr(); break;
X case '\f': pff(); break;
X default:
X if(isprint(*s&0x7F))
X pchar(*s);
X break;
X }
X s++;
X }
X endline();
X putchar('\n');
X}
END_OF_FILE
if test 6381 -ne `wc -c <'preps.c'`; then
echo shar: \"'preps.c'\" unpacked with wrong size!
fi
# end of 'preps.c'
fi
echo shar: End of shell archive.
exit 0
